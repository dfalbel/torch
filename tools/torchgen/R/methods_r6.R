
method_r6 <- function() {

  tm <- tensor_methods()

  unq_names <- tm %>%
    purrr::map_chr(~.x$name) %>%
    unique() %>%
    purrr::map(~declarations_with_name(tm, .x))

  methods <- unq_names %>%
    purrr::map_chr(method_r6_code)

  code <- paste(
    c("# Autogenerated file", methods),
    collapse = "\n\n"
  )

  code
}


#' Generate wraper code given a collection of methods with
#' the same name.
#'
#' @param methods A collection of methods as you would get with
#'  `tensor_methods() %>% declarations_with_name("abs")`
#'
method_r6_code <- function(methods) {
  glue::glue('
  `torch::Tensor`$set("public", "{method_r6_name(methods)}", function({method_r6_signature(methods)}) {{
    {method_r6_body(methods)}
  }})
  ')
}

method_r6_name <- function(method) {
  nm <- method[["name"]]

  if (is.null(nm))
    nm <- method[[1]]$name

  nm
}

method_r6_signature <- function(methods) {

  arguments <- get_possible_argument_names(methods)
  defaults <- get_default_values(methods)

  arguments <- defaults[arguments]
  arguments[["self"]] <- NULL
  arguments %>%
    purrr::imap_chr(function(default, name) {
      if (!is.na(default))
        name <- glue::glue("{name} = {default}")

      name
    }) %>%
    paste(collapse = ", ")
}


method_r6_return <- function(methods) {
  returns <- get_return_types(methods)

  lengths <- purrr::map_int(returns, length)
  all_returns <- purrr::flatten_chr(returns)

  if (all(lengths == 1)) {

    if (all(all_returns == "Tensor"))
      return("`torch::Tensor`$dispatch(out)")
    else if (all(all_returns == "Tensor &"))
      return("invisible(self)")
    else if (all(all_returns %in% c("bool", "int64_t", "double")))
      return("out")
    else if (all(all_returns == "std::vector<Tensor>"))
      return("lapply(out, `torch::Tensor`$dispatch)")
    else if (all(all_returns == "void"))
      return("invisible(NULL)")
    else if (all(all_returns == "QScheme"))
      return("`torch::QScheme`$dispatch(out)")
    else if (all(all_returns == "Scalar"))
      return("as.array(out)")

  } else {

    if (all(all_returns == "Tensor")) {
      return("if (length(out) == 1) out else lapply(out, `torch::Tensor`$dispatch)")
    }

  }

  "invisible(NULL)"
}

method_r6_body <- function(methods) {
  glue::glue('
  args <- args_to_pointers(as.list(environment()))
  args[["self"]] <- self$pointer
  out <- do.call({method_s4_generic_name(methods)}, args)
  {method_r6_return(methods)}
')
}

