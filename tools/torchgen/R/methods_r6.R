
method_r6 <- function() {

  tm <- tensor_methods()

  unq_names <- tm %>%
    purrr::map_chr(~.x$name) %>%
    unique() %>%
    purrr::map(~declarations_with_name(tm, .x))

  methods <- unq_names %>%
    purrr::map_chr(method_r6_code)

  code <- paste(
    c("# Autogenerated file", methods),
    collapse = "\n\n"
  )

  code
}


#' Generate wraper code given a collection of methods with
#' the same name.
#'
#' @param methods A collection of methods as you would get with
#'  `tensor_methods() %>% declarations_with_name("abs")`
#'
method_r6_code <- function(methods) {
  glue::glue('
  `torch::Tensor`$set("public", "{method_r6_name(methods)}", function({method_r6_signature(methods)}) {{
    {method_r6_body(methods)}
  }})
  ')
}

method_r6_name <- function(method) {
  nm <- method[["name"]]

  if (is.null(nm))
    nm <- method[[1]]$name

  nm
}

method_r6_signature <- function(methods) {

  arguments <- get_possible_argument_names(methods)
  defaults <- get_default_values(methods)

  arguments <- defaults[arguments]
  arguments[["self"]] <- NULL
  arguments %>%
    imap_chr(function(default, name) {
      if (!is.na(default))
        name <- glue::glue("{name} = {default}")

      name
    }) %>%
    paste(collapse = ", ")
}

method_r6_body <- function(methods) {
  glue::glue('
  args <- as.list(environment())
  args[["self"]] <- self$pointer
  `torch::Tensor`$dispatch(do.call({method_s4_generic_name(methods)}, args))
')
}

