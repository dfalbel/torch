// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "torch_types.h"
#include <Rcpp.h>

using namespace Rcpp;

// tensor_from_r_
Rcpp::XPtr<torch::Tensor> tensor_from_r_(SEXP x, std::vector<int64_t> dim, Rcpp::Nullable<std::string> dtype, Rcpp::Nullable<std::string> device, bool requires_grad);
RcppExport SEXP _torch_tensor_from_r_(SEXP xSEXP, SEXP dimSEXP, SEXP dtypeSEXP, SEXP deviceSEXP, SEXP requires_gradSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    Rcpp::traits::input_parameter< std::vector<int64_t> >::type dim(dimSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<std::string> >::type dtype(dtypeSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<std::string> >::type device(deviceSEXP);
    Rcpp::traits::input_parameter< bool >::type requires_grad(requires_gradSEXP);
    rcpp_result_gen = Rcpp::wrap(tensor_from_r_(x, dim, dtype, device, requires_grad));
    return rcpp_result_gen;
END_RCPP
}
// tensor_
Rcpp::XPtr<torch::Tensor> tensor_(Rcpp::XPtr<torch::Tensor> x, Rcpp::Nullable<std::string> dtype, Rcpp::Nullable<std::string> device, bool requires_grad);
RcppExport SEXP _torch_tensor_(SEXP xSEXP, SEXP dtypeSEXP, SEXP deviceSEXP, SEXP requires_gradSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::XPtr<torch::Tensor> >::type x(xSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<std::string> >::type dtype(dtypeSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<std::string> >::type device(deviceSEXP);
    Rcpp::traits::input_parameter< bool >::type requires_grad(requires_gradSEXP);
    rcpp_result_gen = Rcpp::wrap(tensor_(x, dtype, device, requires_grad));
    return rcpp_result_gen;
END_RCPP
}
// as_array_tensor_
Rcpp::List as_array_tensor_(Rcpp::XPtr<torch::Tensor> x);
RcppExport SEXP _torch_as_array_tensor_(SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::XPtr<torch::Tensor> >::type x(xSEXP);
    rcpp_result_gen = Rcpp::wrap(as_array_tensor_(x));
    return rcpp_result_gen;
END_RCPP
}
// cuda_is_available_
bool cuda_is_available_();
RcppExport SEXP _torch_cuda_is_available_() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    rcpp_result_gen = Rcpp::wrap(cuda_is_available_());
    return rcpp_result_gen;
END_RCPP
}
// set_grad_mode
void set_grad_mode(bool enabled);
RcppExport SEXP _torch_set_grad_mode(SEXP enabledSEXP) {
BEGIN_RCPP
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< bool >::type enabled(enabledSEXP);
    set_grad_mode(enabled);
    return R_NilValue;
END_RCPP
}
// torch_argmax_
Rcpp::XPtr<torch::Tensor> torch_argmax_(Rcpp::XPtr<torch::Tensor> self, Rcpp::Nullable<int64_t> dim, bool keepdim);
RcppExport SEXP _torch_torch_argmax_(SEXP selfSEXP, SEXP dimSEXP, SEXP keepdimSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::XPtr<torch::Tensor> >::type self(selfSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<int64_t> >::type dim(dimSEXP);
    Rcpp::traits::input_parameter< bool >::type keepdim(keepdimSEXP);
    rcpp_result_gen = Rcpp::wrap(torch_argmax_(self, dim, keepdim));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_torch_tensor_from_r_", (DL_FUNC) &_torch_tensor_from_r_, 5},
    {"_torch_tensor_", (DL_FUNC) &_torch_tensor_, 4},
    {"_torch_as_array_tensor_", (DL_FUNC) &_torch_as_array_tensor_, 1},
    {"_torch_cuda_is_available_", (DL_FUNC) &_torch_cuda_is_available_, 0},
    {"_torch_set_grad_mode", (DL_FUNC) &_torch_set_grad_mode, 1},
    {"_torch_torch_argmax_", (DL_FUNC) &_torch_torch_argmax_, 3},
    {NULL, NULL, 0}
};

RcppExport void R_init_torch(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
